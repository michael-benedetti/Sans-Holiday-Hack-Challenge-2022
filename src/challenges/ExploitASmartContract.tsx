import ChallengeSummary from "../ChallengeSummary";
import {Accordion, AccordionDetails} from "@mui/material";
import {ChallengeDetails, Content, ContentImage, IC, Pop, StyledSyntaxHighligher} from "../Common";
import QuoteCard from "../QuoteCard";
import characters from "../characters";

function ExploitASmartContract() {
  return (
    <Accordion>
      <ChallengeSummary title={"Exploit a Smart Contract"} difficulty={5}/>
      <AccordionDetails>
        <ChallengeDetails>
          Exploit flaws in a smart contract to buy yourself a Bored Sporc NFT. Find hints for this objective hidden throughout the tunnels.
        </ChallengeDetails>
        <Content>
          As the final challenge, we need to exploit a smart contract. Heading towards the challenge terminal, we meet
          up with <Pop>Luigi</Pop>:
        </Content>
        <QuoteCard
          character={characters.luigi}
          quote={0}
        />
        <Content>
          At the nearby terminal, we can see that we have the ability to purchase a <Pop>Sporc NFT</Pop> (if we are on the presale
          list). Visiting the purchase page gives us some details on how we can verify that our wallet address has been
          pre-approved. It mentions that it is checking against a <Pop>Merkel Tree</Pop>, which conveniently we
          have <a href="https://decentralizedthoughts.github.io/2020-12-22-what-is-a-merkle-tree/">some</a>
          &nbsp;<a href="https://www.youtube.com/watch?v=Qt_RWBq63S8">relevant</a>
          &nbsp;<a href="https://github.com/QPetabyte/Merkle_Trees">resources</a>
          &nbsp;from <Pop>Professor Querty Petabyte</Pop> to review. Before we continue, we'll need to send <IC>100</IC> <Pop>Kringle
          Coin</Pop> to the provided wallet address, and we can use the nearby KC terminal to do so.
        </Content>
        <Content>
          Looking back at the purchase form, we see that it accepts a wallet address, and proof values. From reviewing
          material
          about <Pop>Merkel trees</Pop>, we know that the proof values will be used to validate our wallet address as a
          leaf in the tree. It
          does this by calculating the root value with the provided address and proof values, and ensuring it matches
          the known
          root hash. Let's inspect the network traffic when we interact with the form. Entering <IC>0x1</IC> for wallet
          address and
          <IC>0x2</IC> for proof values, we see the following <Pop>POST</Pop> payload is sent to
          the <Pop>/presale</Pop> endpoint:
        </Content>
        <StyledSyntaxHighligher language={"json"}>
          {
            `{
  "WalletID": "0x1",
  "Root": "0x52cfdfdcba8efebabd9ecc2c60e6f482ab30bdc6acf8f9bd0600de83701e15f1",
  "Proof": "0x2",
  "Validate": "true",
  "Session": "00b7623f-a1e7-4e00-9f66-514ec2ce4931"
}`
          }
        </StyledSyntaxHighligher>
        <Content>
          Interestingly, we are sending the root hash along with our other user-supplied data. As we just covered,
          validating a
          leaf belongs to a merkel tree should be checking against a known pre-calculated root hash. It's possible that
          there is
          a flaw in the validation process here, and the server is instead checking against the root value the client
          sends in
          the <Pop>POST</Pop> request.
        </Content>
        <Content>
          We can leverage <a href="https://github.com/QPetabyte/Merkle_Trees">Professor Petabyte's git repo</a> to help
          generate proof values
          to send. We just need to update the allowlist to include any value we choose, plus our wallet address. Since
          my wallet
          address was the second item in our allowlist, we also need to update the <IC>get_proof</IC> function to point
          at index <IC>1</IC>:
        </Content>
        <StyledSyntaxHighligher language={"python"}>
          allowlist = ['0x3ee1282DA741B3F1e6c02D4CFb8707aF98010080', '0xa5daD048995eDAc0EfBAfbbF76309401BC870444']
        </StyledSyntaxHighligher>
        <StyledSyntaxHighligher language={"python"}>
          print('Proof:', mt.get_proof(Web3.solidityKeccak(['bytes'], [allowlist[1]])))
        </StyledSyntaxHighligher>
        <Content>
          Running the program now yields the following root and proof values:
        </Content>
        <StyledSyntaxHighligher langauge={"sh"}>
          {`mt_user@3b7b82bfe013:/src$ python3 merkle_tree.py
Root: 0xa72e920072b3eb0688b98485435129c29a33cd505bac86703df57b1f08d07c1b
Proof: ['0x11ab4c195a48373d733e9de04093aa8511357384fe7473a802d79898b762fc35']`}
        </StyledSyntaxHighligher>
        <Content>
          Heading back to the purchase page, we can intercept our outgoing <Pop>POST</Pop> request with <Pop>Burp
          Suite</Pop> and modify the root value
          to match our pre-calculated root:
        </Content>
        <ContentImage src={"images/esc_1.png"}/>
        <Content>
          Sending this modified request results in a successful purchase attempt, and we are now the proud owners of the
          best <Pop>Sporc NFT</Pop> in existence:
        </Content>
        <ContentImage src={"images/best_sporc.png"}/>
        <Content>
          As expected, we once again run into <Pop>Grinchum</Pop>:
        </Content>
        <QuoteCard
          character={characters.grinchum}
          quote={4}
        />
      </AccordionDetails>
    </Accordion>
  )
}

export default ExploitASmartContract
